# Dart OOP

## üìò Phase 1: Dart OOP Foundations

### 1. Introduction to OOP in Dart
**Learning Outcome**: Understand the four pillars of OOP‚Äîencapsulation, inheritance, abstraction, and polymorphism‚Äîand how Dart supports them.

### 2. Classes and Objects
**Learning Outcome**: Define classes and create objects to model real-world entities.

### 3. Instance Variables and Methods
**Learning Outcome**: Use instance variables and methods to store and manipulate object data.

### 4. Constructors
**Learning Outcome**: Initialize objects using default, named, and factory constructors.

### 5. Class Modifiers
**Learning Outcome**: Apply `final`, `const`, `static`, and `late` to control class behavior and memory usage.

## üß¨ Phase 2: Core OOP Principles

### 6. Encapsulation
**Learning Outcome**: Protect object data using private fields and public getters/setters.

### 7. Inheritance
**Learning Outcome**: Reuse and extend functionality using class inheritance.

### 8. Abstract Classes and Interfaces
**Learning Outcome**: Use abstract classes and the `implements` keyword to define contracts for subclasses.

### 9. Polymorphism
**Learning Outcome**: Use method overriding and interface implementation for flexible code behavior.

### 10. Mixins
**Learning Outcome**: Reuse code across multiple classes without inheritance.

## ‚öôÔ∏è Phase 3: Advanced Class Features

### 11. Singleton Pattern
**Learning Outcome**: Ensure a class has only one instance using the singleton pattern.

### 12. Operator Overloading
**Learning Outcome**: Customize behavior of operators like `+`, `==`, etc., for your classes.

## üì¶ Phase 4: Code Organization and Reusability

### 13. Dart Libraries and Private Fields
**Learning Outcome**: Organize code into libraries and use privacy conventions (`_`) for encapsulation.

### 14. Dart Generics
**Learning Outcome**: Write reusable and type-safe code using generics.

### 15. Creating Records
**Learning Outcome**: Use Dart records to group multiple values without creating a class.

## üßµ Phase 5: Error Handling and Synchronous Workflows

### 16. Exception Handling
**Learning Outcome**: Handle errors gracefully using `try`, `catch`, `finally`, and `throw`.

### 17. Iterables and Lists
**Learning Outcome**: Work with Dart collections like `List`, `Set`, and `Map`.

### 18. Dart Synchronous Workflows
**Learning Outcome**: Write efficient synchronous code using loops, conditionals, and collections.

## üîÑ Phase 6: Asynchronous Programming

### 19. Futures and async/await
**Learning Outcome**: Perform asynchronous operations using `Future`, `async`, and `await`.

### 20. Futures In-depth
**Learning Outcome**: Chain futures, handle errors, and understand `Future.value`, `Future.delayed`, etc.

### 21. Streams
**Learning Outcome**: Handle sequences of asynchronous data using `Stream`.

### 22. Streams In-depth
**Learning Outcome**: Use broadcast streams, transform data, and manage stream subscriptions.

## üß† Phase 7: Concurrency and Isolates

### 23. Dart Isolates Overview
**Learning Outcome**: Understand Dart‚Äôs concurrency model and isolate basics.

### 24. Event Loop, Event Queue, and Microtask Queue
**Learning Outcome**: Learn how Dart schedules and executes tasks in a single-threaded environment.

### 25. Isolate Structure and Memory
**Learning Outcome**: Understand isolate memory isolation and message passing.

### 26. Parallelism and Isolate Groups
**Learning Outcome**: Run tasks in parallel and communicate between isolate groups.
